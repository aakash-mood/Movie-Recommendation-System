# -*- coding: utf-8 -*-
"""DM_HW3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DOkl2UH7BUV48kqvjF6J_HCLVbBOD5Ar
"""

import numpy as np
import pandas as pd
from scipy.spatial.distance import cdist
from sklearn.preprocessing import StandardScaler, MinMaxScaler, binarize, normalize
from sklearn.metrics.pairwise import cosine_similarity, euclidean_distances
from sklearn.metrics import accuracy_score
from collections import Counter
import time
import sys

df = pd.read_csv('./kmeans_data/data.csv',header=None)
data=df.values
label = pd.read_csv('./kmeans_data/label.csv',header=None).values
K=10

def euclidean_distance(point1, point2):
    return np.sqrt(np.sum((point1 - point2) ** 2))

def cosine_distance(x1, x2):
    return 1 - cosine_similarity(x1.reshape(1, -1), x2.reshape(1, -1))[0, 0]

def jaccard_distance(x1, x2):
    intersection = np.sum(np.minimum(x1, x2))
    union = np.sum(np.maximum(x1, x2))
    return 1 - (intersection / union)

# Modify the kmeans function to track SSE values at each iteration
def kmeans(X, k, distance_measure='euclidean', max_iters=100, stopping_criteria=None):
    n_samples, n_features = X.shape

    # Initialize centroids
    centroids = X[np.random.choice(n_samples, k, replace=False)]
    prev_centroids = centroids.copy()

    # Stop criteria variables
    max_iters_reached = False
    sse_increase = False
    no_change_in_centroids = False

    # Track iterations, time, and SSE values
    iterations = 0
    start_time = time.time()
    sse_values = []
    sse=sys.float_info.max
    new_sse=0

    for _ in range(max_iters):
        # Assign each sample to the nearest centroid
        distances = np.zeros((n_samples, k))
        for i in range(k):
            if distance_measure == 'euclidean':
                distances[:, i] = np.array([euclidean_distance(x, centroids[i]) for x in X])
            elif distance_measure == 'cosine':
                distances[:, i] = np.array([cosine_distance(x, centroids[i]) for x in X])
            elif distance_measure == 'jaccard':
                distances[:, i] = np.array([jaccard_distance(x, centroids[i]) for x in X])

        labels = np.argmin(distances, axis=1)

        # Update centroids
        new_centroids = np.array([X[labels == j].mean(axis=0) for j in range(k)])

        # Calculate SSE
        if distance_measure == 'euclidean':
            new_sse = np.sum(np.sum([euclidean_distance(x, centroids[i]) ** 2 for x in X[labels == i]]) for i in range(len(centroids)))
        elif distance_measure == 'cosine':
            new_sse = np.sum(np.sum([cosine_distance(x, centroids[i]) ** 2 for x in X[labels == i]]) for i in range(len(centroids)))
        elif distance_measure == 'jaccard':
            new_sse = np.sum(np.sum([jaccard_distance(x, centroids[i]) ** 2 for x in X[labels == i]]) for i in range(len(centroids)))

        if stopping_criteria == 'centroid_change':
            if np.allclose(centroids, new_centroids):
                break
        elif stopping_criteria == 'sse_increase':
            if new_sse > sse:
                break
            prev_sse = sse
        elif stopping_criteria == 'max_iters':
            if iterations == max_iters - 1:
                break

        centroids = new_centroids
        sse = new_sse

    end_time = time.time()
    elapsed_time = end_time - start_time

    return labels, centroids, sse

# Euclidean distance
scaler = StandardScaler()
data_standardized = scaler.fit_transform(data)
labels_euclidean_centroid, centroids_euclidean_centroid, sse_values_euclidean_centroid= kmeans(data_standardized, K, 'euclidean',stopping_criteria='centroid_change')
labels_euclidean_sse, centroids_euclidean_sse, sse_values_euclidean_sse= kmeans(data_standardized, K, 'euclidean', max_iters=10,stopping_criteria='sse_increase')
labels_euclidean_itr, centroids_euclidean_itr, sse_values_euclidean_itr= kmeans(data_standardized, K, 'euclidean',stopping_criteria='max_iters')

data_normalized = normalize(data)
labels_cosine_centroid, centroids_cosine_centroid, sse_values_cosine_centroid= kmeans(data_normalized, K, 'cosine',stopping_criteria='centroid_change')
labels_cosine_sse, centroids_cosine_sse, sse_values_cosine_sse= kmeans(data_normalized, K, 'cosine', max_iters=10,stopping_criteria='sse_increase')
labels_cosine_itr, centroids_cosine_itr, sse_values_cosine_itr= kmeans(data_normalized, K, 'cosine',stopping_criteria='max_iters')

data_binarized = binarize(data)
labels_jaccard_centroid, centroids_jaccard_centroid, sse_values_jaccard_centroid  = kmeans(data_binarized, K, 'jaccard',stopping_criteria='centroid_change')
labels_jaccard_sse, centroids_jaccard_sse, sse_values_jaccard_sse  = kmeans(data_binarized, K, 'jaccard', max_iters=10,stopping_criteria='sse_increase')
labels_jaccard_itr, centroids_jaccard_itr, sse_values_jaccard_itr = kmeans(data_binarized, K, 'jaccard',stopping_criteria='max_iters')

# Print SSE values and terminating conditions
print("Euclidean-K-means:")
print("No change in centroids:", sse_values_euclidean_centroid)
print("SSE increase:", sse_values_euclidean_sse)
print("Max iterations reached:", sse_values_euclidean_itr)
# print("SSE values:", sse_values_euclidean)

print("\nCosine-K-means:")
print("No change in centroids:", sse_values_cosine_centroid)
print("SSE increase:", sse_values_cosine_sse)
print("Max iterations reached:", sse_values_cosine_itr)
# print("SSE values:", sse_values_cosine)

print("\nJaccard-K-means:")
print("No change in centroids:", sse_values_jaccard_centroid)
print("SSE increase:", sse_values_jaccard_sse)
print("Max iterations reached:", sse_values_jaccard_itr)
# print("SSE values:", sse_values_jaccard)
